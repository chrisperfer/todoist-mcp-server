#!/usr/bin/env node

import { randomUUID } from 'crypto';
import url from 'url';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import {
    initializeApi,
    findTask,
    getProjectPath,
    executeSyncCommand,
    executeSyncCommands,
    formatJsonOutput,
    parseBaseOptions
} from './lib/task-utils.js';
import {
    resolveTaskId,
    resolveProjectId,
    resolveSectionId
} from './lib/id-utils.js';

// Reuse existing task manipulation functions
async function moveTask(api, task, options) {
    let targetId;
    let projectId;

    switch (options.destination) {
        case 'parent':
            try {
                const parentId = await resolveTaskId(api, options.id);
                targetId = { parent_id: parentId };
                const parentTask = (await api.getTasks()).find(t => t.id === parentId);
                if (parentTask) projectId = parentTask.projectId;
            } catch (error) {
                console.error(`Error: Parent task "${options.id}" not found`);
                process.exit(1);
            }
            break;

        case 'section':
            try {
                targetId = { section_id: options.id };
                const sections = await api.getSections();
                const section = sections.find(s => s.id === options.id.toString());
                if (!section) {
                    throw new Error(`Section not found: ${options.id}`);
                }
                projectId = section.projectId;
            } catch (error) {
                console.error(`Error moving task to section "${options.id}"`);
                process.exit(1);
            }
            break;

        case 'project':
            try {
                projectId = await resolveProjectId(api, options.id);
                targetId = { project_id: projectId };
            } catch (error) {
                console.error(`Error: Project "${options.id}" not found`);
                process.exit(1);
            }
            break;
    }

    const command = {
        type: 'item_move',
        uuid: randomUUID(),
        args: {
            id: task.id,
            ...targetId
        }
    };

    await executeSyncCommand(process.env.TODOIST_API_TOKEN, command);

    if (options.json) {
        console.log(formatJsonOutput(task, 'moved', {
            from: {
                project: await getProjectPath(api, task.projectId),
                section: task.sectionId
            },
            to: {
                project: await getProjectPath(api, projectId),
                section: targetId.section_id,
                parent: targetId.parent_id
            }
        }));
    } else {
        console.log(`Task moved: ${task.content}`);
        if (projectId !== task.projectId) {
            console.log(`From project: ${await getProjectPath(api, task.projectId)}`);
            console.log(`To project: ${await getProjectPath(api, projectId)}`);
        }
        if (targetId.section_id) {
            const sections = await api.getSections();
            const toSection = sections.find(s => s.id === targetId.section_id);
            console.log(`To section: ${toSection ? toSection.name : 'unknown'}`);
        }
        if (targetId.parent_id) {
            const parentTask = (await api.getTasks()).find(t => t.id === targetId.parent_id);
            console.log(`To parent: ${parentTask ? parentTask.content : targetId.parent_id}`);
        }
    }
}

async function batchMoveTask(api, filter, options) {
    // Get tasks matching the filter
    const tasks = await api.getTasks();
    const matchingTasks = tasks.filter(task => {
        // If filter is a task ID, match exactly
        if (/^\d+$/.test(filter)) {
            return task.id === filter;
        }
        
        // Otherwise, use the filter as a Todoist query
        // This is a simplified version - in reality you'd want to use Todoist's query parser
        return task.content.toLowerCase().includes(filter.toLowerCase());
    });

    if (matchingTasks.length === 0) {
        console.error(`No tasks found matching filter: ${filter}`);
        process.exit(1);
    }

    console.log(`Found ${matchingTasks.length} tasks to move`);
    
    // Move each task
    for (const task of matchingTasks) {
        await moveTask(api, task, options);
    }
}

async function updateTask(api, task, options) {
    if (options.complete) {
        try {
            await api.closeTask(task.id);
            console.log(`Task completed: ${task.content}`);
            return;
        } catch (error) {
            console.error("Error completing task:", error.message);
            process.exit(1);
        }
    }

    const updateData = {};

    // Handle labels/tags
    if (options.labels) {
        const existingLabels = task.labels || [];
        
        if (options.addLabels) {
            updateData.labels = [...new Set([...existingLabels, ...options.labels])];
        } else if (options.removeLabels) {
            updateData.labels = existingLabels.filter(l => !options.labels.includes(l));
        } else {
            updateData.labels = options.labels;
        }
    }

    // Handle other updates
    if (options.content) updateData.content = options.content;
    if (options.description) updateData.description = options.description;
    if (options.priority) updateData.priority = parseInt(options.priority);
    if (options.dueString) updateData.due_string = options.dueString;
    if (options.dueDate) updateData.due_date = options.dueDate;

    const command = {
        type: 'item_update',
        uuid: randomUUID(),
        args: {
            id: task.id,
            ...updateData
        }
    };

    await executeSyncCommand(process.env.TODOIST_API_TOKEN, command);

    if (options.json) {
        console.log(formatJsonOutput(task, 'updated', {
            labels: updateData.labels || task.labels,
            updates: updateData
        }));
    } else {
        console.log(`Task updated: ${task.content}`);
        if (updateData.labels) {
            console.log(`Labels: ${updateData.labels.join(', ') || 'none'}`);
        }
        if (updateData.content) {
            console.log(`New content: ${updateData.content}`);
        }
        if (updateData.priority) {
            console.log(`New priority: ${updateData.priority}`);
        }
        if (updateData.due_string || updateData.due_date) {
            console.log(`New due date: ${updateData.due_string || updateData.due_date}`);
        }
    }
}

async function addTask(api, content, options = {}) {
    let projectId = null;
    let sectionId = null;
    let parentId = null;

    if (options.project) {
        try {
            projectId = await resolveProjectId(api, options.project);
        } catch (error) {
            console.error(`Error: Project "${options.project}" not found`);
            process.exit(1);
        }
    }

    if (options.section) {
        try {
            sectionId = await resolveSectionId(api, options.section);
        } catch (error) {
            console.error(`Error: Section "${options.section}" not found`);
            process.exit(1);
        }
    }

    if (options.parent) {
        try {
            parentId = await resolveTaskId(api, options.parent);
        } catch (error) {
            console.error(`Error: Parent task "${options.parent}" not found`);
            process.exit(1);
        }
    }

    const command = {
        type: 'item_add',
        uuid: randomUUID(),
        temp_id: randomUUID(),
        args: {
            content,
            ...(projectId && { project_id: projectId }),
            ...(sectionId && { section_id: sectionId }),
            ...(parentId && { parent_id: parentId }),
            ...(options.priority && { priority: parseInt(options.priority) }),
            ...(options.dueString && { due_string: options.dueString }),
            ...(options.dueDate && { due_date: options.dueDate }),
            ...(options.labels && { labels: options.labels })
        }
    };

    await executeSyncCommand(process.env.TODOIST_API_TOKEN, command);

    // Get the newly created task
    const tasks = await api.getTasks();
    const newTask = tasks.find(t => 
        t.content === content && 
        (!projectId || t.projectId === projectId.toString()) &&
        (!sectionId || t.sectionId === sectionId.toString()) &&
        (!parentId || t.parentId === parentId.toString())
    );

    if (options.json) {
        console.log(formatJsonOutput(newTask, 'created'));
    } else {
        console.log(`Task created: ${content}`);
        if (projectId) {
            console.log(`Project: ${await getProjectPath(api, projectId)}`);
        }
        if (sectionId) {
            const sections = await api.getSections();
            const section = sections.find(s => s.id === sectionId);
            console.log(`Section: ${section ? section.name : sectionId}`);
        }
        if (parentId) {
            const parentTask = tasks.find(t => t.id === parentId);
            console.log(`Parent: ${parentTask ? parentTask.content : parentId}`);
        }
        if (options.priority) console.log(`Priority: ${options.priority}`);
        if (options.labels) console.log(`Labels: ${options.labels.join(', ')}`);
    }
}

async function main() {
    const argv = yargs(hideBin(process.argv))
        .command('move', 'Move a task to a different location', {
            task: {
                description: 'Task ID or content to move',
                type: 'string',
                demandOption: true
            },
            'to-project': {
                description: 'Move to project (ID or name)',
                type: 'string',
                conflicts: ['to-section', 'to-parent']
            },
            'to-section': {
                description: 'Move to section (ID or name)',
                type: 'string',
                conflicts: ['to-project', 'to-parent']
            },
            'to-parent': {
                description: 'Move as subtask of parent (ID or content)',
                type: 'string',
                conflicts: ['to-project', 'to-section']
            },
            json: {
                description: 'Output in JSON format',
                type: 'boolean',
                default: false
            }
        })
        .command('batch-move', 'Move multiple tasks matching a filter', {
            filter: {
                description: 'Todoist filter query or task ID',
                type: 'string',
                demandOption: true
            },
            'to-project': {
                description: 'Move to project (ID or name)',
                type: 'string',
                conflicts: ['to-section', 'to-parent']
            },
            'to-section': {
                description: 'Move to section (ID or name)',
                type: 'string',
                conflicts: ['to-project', 'to-parent']
            },
            'to-parent': {
                description: 'Move as subtask of parent (ID or content)',
                type: 'string',
                conflicts: ['to-project', 'to-section']
            },
            json: {
                description: 'Output in JSON format',
                type: 'boolean',
                default: false
            }
        })
        .command('update', 'Update a task', {
            task: {
                description: 'Task ID or content to update',
                type: 'string',
                demandOption: true
            },
            content: {
                description: 'New task content',
                type: 'string'
            },
            description: {
                description: 'New task description',
                type: 'string'
            },
            priority: {
                description: 'New priority (1-4)',
                type: 'number',
                choices: [1, 2, 3, 4]
            },
            'due-string': {
                description: 'New due date as string (e.g., "tomorrow", "next week")',
                type: 'string'
            },
            'due-date': {
                description: 'New due date (YYYY-MM-DD)',
                type: 'string'
            },
            labels: {
                description: 'Set labels (comma-separated)',
                type: 'array',
                string: true,
                coerce: arg => typeof arg === 'string' ? arg.split(',').map(s => s.trim()) : arg
            },
            'add-labels': {
                description: 'Add labels to existing ones (comma-separated)',
                type: 'array',
                string: true,
                coerce: arg => typeof arg === 'string' ? arg.split(',').map(s => s.trim()) : arg
            },
            'remove-labels': {
                description: 'Remove labels (comma-separated)',
                type: 'array',
                string: true,
                coerce: arg => typeof arg === 'string' ? arg.split(',').map(s => s.trim()) : arg
            },
            complete: {
                description: 'Mark task as complete',
                type: 'boolean',
                default: false
            },
            json: {
                description: 'Output in JSON format',
                type: 'boolean',
                default: false
            }
        })
        .command('add', 'Add a new task', {
            content: {
                description: 'Task content',
                type: 'string',
                demandOption: true
            },
            project: {
                description: 'Project ID or name',
                type: 'string'
            },
            section: {
                description: 'Section ID or name',
                type: 'string'
            },
            parent: {
                description: 'Parent task ID or content',
                type: 'string'
            },
            priority: {
                description: 'Priority (1-4)',
                type: 'number',
                choices: [1, 2, 3, 4]
            },
            'due-string': {
                description: 'Due date as string (e.g., "tomorrow", "next week")',
                type: 'string'
            },
            'due-date': {
                description: 'Due date (YYYY-MM-DD)',
                type: 'string'
            },
            labels: {
                description: 'Labels (comma-separated)',
                type: 'array',
                string: true,
                coerce: arg => typeof arg === 'string' ? arg.split(',').map(s => s.trim()) : arg
            },
            json: {
                description: 'Output in JSON format',
                type: 'boolean',
                default: false
            }
        })
        .command('batch-add', 'Add multiple tasks', {
            tasks: {
                description: 'Task contents (use quotes for multi-word tasks)',
                type: 'array',
                string: true,
                demandOption: true
            },
            project: {
                description: 'Project ID or name',
                type: 'string'
            },
            section: {
                description: 'Section ID or name',
                type: 'string'
            },
            parent: {
                description: 'Parent task ID or content',
                type: 'string'
            },
            priority: {
                description: 'Priority (1-4)',
                type: 'number',
                choices: [1, 2, 3, 4]
            },
            'due-string': {
                description: 'Due date as string (e.g., "tomorrow", "next week")',
                type: 'string'
            },
            'due-date': {
                description: 'Due date (YYYY-MM-DD)',
                type: 'string'
            },
            labels: {
                description: 'Labels (comma-separated)',
                type: 'array',
                string: true,
                coerce: arg => typeof arg === 'string' ? arg.split(',').map(s => s.trim()) : arg
            },
            json: {
                description: 'Output in JSON format',
                type: 'boolean',
                default: false
            }
        })
        .demandCommand(1, 'You must provide a valid command')
        .help()
        .argv;

    const api = await initializeApi();

    switch (argv._[0]) {
        case 'move': {
            const task = await findTask(api, argv.task);
            if (!task) {
                console.error(`Task not found: ${argv.task}`);
                process.exit(1);
            }

            let destination, id;
            if (argv.toProject) {
                destination = 'project';
                id = argv.toProject;
            } else if (argv.toSection) {
                destination = 'section';
                id = argv.toSection;
            } else if (argv.toParent) {
                destination = 'parent';
                id = argv.toParent;
            } else {
                console.error('Must specify one of: --to-project, --to-section, --to-parent');
                process.exit(1);
            }

            await moveTask(api, task, { destination, id, json: argv.json });
            break;
        }

        case 'batch-move': {
            let destination, id;
            if (argv.toProject) {
                destination = 'project';
                id = argv.toProject;
            } else if (argv.toSection) {
                destination = 'section';
                id = argv.toSection;
            } else if (argv.toParent) {
                destination = 'parent';
                id = argv.toParent;
            } else {
                console.error('Must specify one of: --to-project, --to-section, --to-parent');
                process.exit(1);
            }

            await batchMoveTask(api, argv.filter, { destination, id, json: argv.json });
            break;
        }

        case 'update': {
            const task = await findTask(api, argv.task);
            if (!task) {
                console.error(`Task not found: ${argv.task}`);
                process.exit(1);
            }

            await updateTask(api, task, {
                content: argv.content,
                description: argv.description,
                priority: argv.priority,
                dueString: argv.dueString,
                dueDate: argv.dueDate,
                labels: argv.labels || argv.addLabels || argv.removeLabels,
                addLabels: Boolean(argv.addLabels),
                removeLabels: Boolean(argv.removeLabels),
                complete: argv.complete,
                json: argv.json
            });
            break;
        }

        case 'add': {
            await addTask(api, argv.content, {
                project: argv.project,
                section: argv.section,
                parent: argv.parent,
                priority: argv.priority,
                dueString: argv.dueString,
                dueDate: argv.dueDate,
                labels: argv.labels,
                json: argv.json
            });
            break;
        }

        case 'batch-add': {
            for (const content of argv.tasks) {
                await addTask(api, content, {
                    project: argv.project,
                    section: argv.section,
                    parent: argv.parent,
                    priority: argv.priority,
                    dueString: argv.dueString,
                    dueDate: argv.dueDate,
                    labels: argv.labels,
                    json: argv.json
                });
            }
            break;
        }
    }
}

if (import.meta.url === url.pathToFileURL(process.argv[1]).href) {
    main().catch(error => {
        console.error('Error:', error.message);
        process.exit(1);
    });
}

export { moveTask, batchMoveTask, updateTask, addTask }; 